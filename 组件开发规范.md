---
title: 组件开发规范
author: Dadajia
created: 2024-11-21 02:59
last_modified: 2024-11-21 03:00
---
# 组件开发规范及指南

## 1.	简介

### 1.1 编写目的

本文档的编写目的是明确说明项目公共组件开发规范指南。为提高项目组件开发的质量和可维护性，最终提高软件产品的生产力，对组件设计开发过程做出统一的规范约束。

### 1.2	术语和缩写

术语/缩写     | 含    义
-------- | -----
规则  | 开发时强制必须遵守的原则。
建议  | 开发时必须加以考虑的原则。
谨慎  | 开发时必须谨慎使用的原则。
说明  | 对此规则或建议进行必要的解释。

## 2.	组件开发规范

### 2.1	组件开发基础规范

本部分为组件开发基础规范，涵盖组件开发过程中标准写法以及推荐写法，增强组件的可阅读性以及维护性，提高组件开发的规范程度。

#### 2.1.1 [规则]：组件要符合Web5.0开发规范

> **[说明]：**开发的公共组件，代码要符合5.0开发规范，可阅览 Web5.0开发规范.md。
#### 2.1.2 [规则]：新增的组件要提交代码审核

> **[说明]：**新开发的公共组件需要提交代码审核流程，具体审核人与工作组长沟通，审核人需涉及到各个相关部门，如视频组、非视频组等，以此来增强组件的适用性、稳定性。

#### 2.1.3 [规则]：提供组件说明文档以及上传代码到零码平台

> **[说明]：**新开发的组件需要添加相应的md说明文档,格式参照HC-UI已有文档格式，待组件成熟后，如果该组件具有普遍性，将md文件和组件源码添加到HC-UI框架中（合并代码到远程分支，会有人审核是否符合上传规范），HC-UI集成了IPSC的所有公共组件和业务组件，托管在零码平台上， 申请权限可@郑云9帮忙处理。
HC-UI线上组件库地址：http://zero.hikvision.com.cn/#/componentsDoc
HC-UI项目地址：https://sys-gitlab.hikvision.com.cn/IPSC/web/research/hc-ui.git

#### 2.1.4 [规则]：公共基础组件必须和业务逻辑完全解耦，业务组件要尽量和业务解耦

> **[说明]：**开发的公共基础组件要和业务逻辑完全解耦，协议和业务需求都由上层来控制，要保证组件的纯度。业务组件要尽量和业务解耦，比如尽量不要把协议这些放到组件中来控制，业务组件可以接收与业务相关的数据，然后进行一些业务处理。目前框架中在components下用base文件夹存放公共基础组件，用integration文件夹存放业务组件。

#### 2.1.5 [规则]：静态资源与组件在同一文件夹下面

> **[说明]：**静态资源与组件在同一文件夹下面，保证静态资源的单一性以及和组件间的关联性，不建议所有静态文件平铺，建议根据文件类型进行子文件夹归类存放,如fonts、image、less 每一个分类为一个文件夹, 有则加相应文件夹，没有则不加相应文件夹。
```js
  //good
  BaseTab/
  |- assets/
  |- - fonts/
  |- - image/
  |- - less/
    ...
  |- index.js
```

#### 2.1.6 [规则]：组件要有一个文件夹盛放所有相关的文件资源

> **[说明]：**在组件文件和components文件夹之间需要有一个组件文件夹包裹文件资源，组件文件夹名采用小驼峰命名法。

```js
  //good
  components/
  |- baseAnchor/
  |- - BaseAnchor.vue 

  //bad
  components/
  |- BaseAnchor.vue

```
#### 2.1.7 [建议]：组件尽量细化成单独文件

> **[说明]：**一个组件能够细化，就把每个细化后的组件单独分成文件，当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。

```js
  //good
  components/
  |- todoList/
  |- - TodoList.vue
  |- - TodoListItem.vue

  //bad
  components/
  |- todoList/
  |- - TodoList.vue
```
#### 2.1.8 [规则]：基础组件命名

> **[说明]：**应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，目前统一使用 Base。

```js
  //good
  components/
  |- baseButton/
  |- - BaseButton.vue
  |- baseTable/
  |- - BaseTable.vue
  |- baseIcon/
  |- - BaseIcon.vue


  //bad
  components/
  |- myButton
  |- - MyButton.vue
  |- vueTable
  |- - VueTable.vue
  |- icon
  |- - Icon.vue
```
#### 2.1.9 [建议]：紧密耦合的组件命名

> **[说明]：**和父组件紧密耦合的子组件应该以父组件名作为前缀命名。如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。

```js
  //good
  components/
  |- todoList/
  |- - TodoList.vue
  |- - TodoListItem.vue
  |- - TodoListItemButton.vue
  components/
  |- searchSidebar/
  |- - SearchSidebar.vue
  |- - SearchSidebarNavigation.vue

    //bad
  components/
  |- todoList/
  |- - TodoList.vue
  |- - TodoItem.vue
  |- - TodoButton.vue
  components/
  |- searchSideba/
  |- - SearchSidebar.vue
  |- - NavigationForSearchSidebar.vue
```

#### 2.1.10 [建议]：组件名中的单词命名

> **[说明]：**组件名应该以高级别的 (通常是一般化描述的) 单词开头，以描述性的修饰词结尾。

```js
  //good
  |- SearchButtonClear.vue
  |- SearchButtonRun.vue
  |- SearchInputQuery.vue
  |- SearchInputExcludeGlob.vue
  |- SettingsCheckboxTerms.vue
  |- SettingsCheckboxLaunchOnStartup.vue

  //bad
  |- ClearSearchButton.vue
  |- ExcludeFromSearchInput.vue
  |- LaunchOnStartupCheckbox.vue
  |- RunSearchButton.vue
  |- SearchInput.vue
  |- TermsCheckbox.vue
```

#### 2.1.11 [规则]：组件要以（大）驼峰式命名

> **[说明]：**开发的公共组件命名时要采用（大）驼峰式命名。
```js
  //good
  组件名： BaseLayout

  //bad
  组件名：baseLayout

```

#### 2.1.12 [规则]：不要轻易引入第三方依赖包

> **[说明]：**因第三方依赖包的稳定性不确定以及体积较大等原因，除非必要，否则不要引入第三方依赖包，如确实需要引入，需要给出引入理由（可在提交代码审核时在流程单上附加描述），并作出相应的优化处理，如按需引入。另外需要提交三方库申请流程，具体流程可阅览 引入第三方库规范及申请流程.docx。引入第三方库规范及申请流程文档地址一般与本文档在同级目录下，如果找不到@郑云9(因文档地址不稳定，暂不附上具体地址)。

#### 2.1.13 [规则]：原有组件上进行二次封装时，需要兼容原有组件所有的特性，向前兼容

> **[说明]：**有时我们会在原有组件上进行二次封装通用组件，此时就需要考虑兼容原有组件的特性，如props等，必须向前兼容。

```vue
  //good
  // 这是一个二次封装的通用组件，其作用是在el-slider组件的基础上增加一个单位显示的功能，该组件名叫SliderUnit
  <template>
    <div :class="[unit !== '' && showInput ? 'slider-unit-wrapper' : '' ]">
      <el-slider
        ref="sliderUnit"
        v-model="value"
        :show-input="showInput"
        v-bind="{...$props, ...$attrs}" // 兼容处理， 向el-slider组件传递调用slider-unit组件时所传递的参数，这些参数本意是传给el-slider, 类似祖组件向孙组件传递参数
      ></el-slider>
      <div class="unit-wrapper" v-show="unit !== '' && visible && showInput" :title="unit"> {{ unit }} </div>
    </div>
  </template>
  <script>
  export default {
    name: 'SliderUnit',
    props: {
      ...
    },
    data () {
      ...
    },
    watch: {
      value(val, oldVal) {
        if (oldVal && val !== oldVal) {
          this.$emit('input', val);
          this.$emit('change', val);
        }
      }
    }
  };

  // 具体使用场景如下
  // unit、show-input  是 slider-unit 本身的props
  // min、max、step等  是 slider-unit 中 el-slider的props ， 
  // 如果slider-unit组件中没有 v-bind="{...$props, ...$attrs}"  这一行代码，没有考虑兼容原有组件的特性
  // 那么 min、max 等属性就会失效
  <slider-unit
    unit="s" 
    show-input
    v-model="value"
    min="0"
    max="100"
    step="1"
  />
```
#### 2.1.14 [规则]：组件要编写好注释

> **[说明]：**开发的公共组件要写好注释，包括data、props和计算属性以及函数等等，注释要能说明其作用、输入参数、输出参数，可参考以下示例。

```js
  //单个文件注释规范
  <!--
  * @FileDescription: 该文件的描述信息
  * @Author: 作者信息
  * @Date: 文件创建时间
  * @LastEditors: 最后更新作者
  * @LastEditTime: 最后更新时间
  -->

  //方法注释规范
  /**
    * @description 方法描述
    * @param {参数类型} 参数名称
    * @param {参数类型} 参数名称
    * @return 没有返回信息写 void / 有返回信息 {返回类型} 描述信息
    */
```
#### 2.1.15 [规则]：组件 props 原子化

> **[说明]：**虽然 Vue.js 支持传递复杂的 JavaScript 对象通过 props 属性，但是应该尽可能的使用原始类型的数据。尽量只使用 JavaScript 原始类型（字符串、数字、布尔值）和函数,尽量避免复杂的对象。这样使得组件 API 清晰直观。只使用原始类型和函数作为 props 使得组件的 API 更接近于 HTML(5) 原生元素。其它开发者更好的理解每一个 prop 的含义、作用。传递过于复杂的对象使得我们不能够清楚的知道哪些属性或方法被组件使用，这使得代码难以重构和维护。

```js
  //good
  <slider-unit
    :values="[10, 20]"
    :min="0"
    :max="100"
    :step="5"
    :unit="s"
    @change="updateResults">
  </slider-unit>
  //bad
  <slider-unit :config="complexConfigObject"></slider-unit>
```


#### 2.1.16 [建议]：模板中使用简单的表达式

> **[说明]：**组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。

```js
  //good
  {{ normalizedFullName }}
  // 复杂表达式已经移入一个计算属性
  computed: {
    normalizedFullName: function () {
      return this.fullName.split(' ').map(function (word) {
        return word[0].toUpperCase() + word.slice(1)
      }).join(' ')
    }
  }

  //bad
  {{
    fullName.split(' ').map(function (word) {
      return word[0].toUpperCase() + word.slice(1)
    }).join(' ')
  }}
```
#### 2.1.17 [建议]：使用简单的计算属性

> **[说明]：**应该把复杂计算属性分割为尽可能多的更简单的 property。。

```js
  //good
  computed: {
    basePrice: function () {
      return this.manufactureCost / (1 - this.profitMargin)
    },
    discount: function () {
      return this.basePrice * (this.discountPercent || 0)
    },
    finalPrice: function () {
      return this.basePrice - this.discount
    }
  }

  //bad
  computed: {
    price: function () {
      let basePrice = this.manufactureCost / (1 - this.profitMargin)
      return (
        basePrice -
        basePrice * (this.discountPercent || 0)
      )
    }
  }
```
#### 2.1.18 [规则]：及时销毁监听器、定时器等

> **[说明]：**监听器、定时器等十分消耗性能，在组件销毁或者不需要再使用监听器、定时器等时，及时销毁。

```js
  //good
  window.addEventListener('resize', resizeEvents);
  scrollBoxDom.addEventListener('scroll', resizeEvents);
  // 通过hook监听组件销毁钩子函数，并取消监听事件
  this.$once('hook:beforeDestroy', () => {
    window.removeEventListener('resize', resizeEvents);
    scrollBoxDom.removeEventListener('scroll', resizeEvents);
  });

```

#### 2.1.19 [建议]：指令缩写

> **[说明]：**指令缩写 (用 : 表示 v-bind:、用 @ 表示 v-on: 和用 # 表示 v-slot:) 在同一组件内指令缩写要保持统一。

```js
  //good
  <input
    :value="newTodoText"
    :placeholder="newTodoInstructions"
  >
  <input
    v-bind:value="newTodoText"
    v-bind:placeholder="newTodoInstructions"
  >
  <input
    @input="onInput"
    @focus="onFocus"
  >
  <input
    v-on:input="onInput"
    v-on:focus="onFocus"
  >

  //bad
  <input
    v-bind:value="newTodoText"
    :placeholder="newTodoInstructions"
  >
  <input
    v-on:input="onInput"
    @focus="onFocus"
  >
```

#### 2.1.20 [建议]：合理使用作用域插槽

> **[说明]：**开发的公共组件如果要复用业务逻辑时，可以考虑使用作用域插槽来增加组件的灵活性，让子组件交出自己的DOM给父组件，实现UI和业务逻辑的分离。

```js
  //good
  <template>
    <div ref="formbox" class="formbox">
      <div ref="configTop" v-show="topStatus">
        <slot name="header"></slot>
      </div>
      <div ref="content" class="base-layout-content">
        <slot name="content"></slot>
      </div>
    </div>
  </template>
```

#### 2.1.21 [规则]：组件事件命名格式

> **[说明]：**  Vue.js 提供的处理函数和表达式都是绑定在 ViewModel 上的，组件的每一个事件都应该按照一个好的命名规范来。一个事件的名字对应组件外的实际操作，达到见名知义的效果，如：upload-success、upload-error。事件命名应该以动词（如 client-api-load） 或是 名词（如 drive-upload-success）结尾。事件名使用 kebab-case，事件绑定的函数名使用小驼峰命名法。

```js
  //good
  <el-tree-node
    v-for="child in root.childNodes"
    :key="getNodeKey(child)"
    :node="child"
    :props="defaultProps"
    :render-after-expand="renderAfterExpand"
    :render-when-expand="renderWhenExpand"
    :render-content="renderContent"
    :prefix-content="prefixContent"
    @node-expand="handleNodeExpand"
    @node-collapse="handleNodeCollapse"
  />
```
#### 2.1.22 [规则]：为 v-for 设置key键值

> **[说明]：**  总是用 key 配合 v-for。在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的对象固化 (object constancy)，也是一种好的做法。
```js
  //good
  <ul>
    <li
      v-for="todo in todos"
      :key="todo.id"
    >
      {{ todo.text }}
    </li>
  </ul>

  //bad
  <ul>
    <li v-for="todo in todos">
      {{ todo.text }}
    </li>
  </ul>
```
#### 2.1.23 [谨慎]：没有在 v-if/v-else-if/v-else 中使用 key

> **[说明]：**如果一组 v-if + v-else 的元素类型相同，最好使用 key (比如两个 `<div> `元素)。默认情况下，Vue 会尽可能高效的更新 DOM。这意味着其在相同类型的元素之间切换时，会修补已存在的元素，而不是将旧的元素移除然后在同一位置添加一个新元素。如果本不相同的元素被识别为相同，则会出现意料之外的结果。

```js
  //good
  <template>
    <div
      v-if="error"
      key="search-status"
    >
      {{ error }}
    </div>
    <div
      v-else
      key="search-results"
    >
      {{ results }}
    </div>
  </template>

  //bad
  <template>
    <div v-if="error">
      {{ error }}
    </div>
    <div v-else>
      {{ results }}
    </div>
  </template>
```

#### 2.1.24 [规则]：避免 v-if 和 v-for 用在一起

> **[说明]：**  永远不要把 v-if 和 v-for 同时用在同一个元素上。一般我们在两种常见的情况下会倾向于这样做：
1.为了过滤一个列表中的项目 (比如 v-for="user in users" v-if="user.isActive")。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。
2.为了避免渲染本应该被隐藏的列表 (比如 v-for="user in users" v-if="shouldShowUsers")。这种情形下，请将 v-if 移动至容器元素上 (比如 ul、ol)。
```js
  //good
  <ul>
    <li
      v-for="user in activeUsers"
      :key="user.id"
    >
      {{ user.name }}
    </li>
  </ul>
  <ul v-if="shouldShowUsers">
    <li
      v-for="user in users"
      :key="user.id"
    >
      {{ user.name }}
    </li>
  </ul>

  //bad
  <ul>
    <li
      v-for="user in users"
      v-if="user.isActive"
      :key="user.id"
    >
      {{ user.name }}
    </li>
  </ul>
  <ul>
    <li
      v-for="user in users"
      v-if="shouldShowUsers"
      :key="user.id"
    >
      {{ user.name }}
    </li>
  </ul>
```
#### 2.1.25 [建议]：标签属性换行

> **[说明]：**建议标签属性超过三个时，依次换行显示。

```js
  // good
  <i
    v-if="icon"
    class="icon-wrapper"
    :style="suffixOffset"
    @click="handleIconClick"
    @mousedown="handleMousedownClick"
    @mouseup="handleMouseupClick"
  />

  //bad
  <i v-if="icon" class="icon-wrapper" :style="suffixOffset" @click="handleIconClick"  @mousedown="handleMousedownClick" @mouseup="handleMouseupClick"/>
```
#### 2.1.26 [建议]：标签属性的顺序优先级

> **[说明]：**建议在书写组件的时候，标签属性按一定的顺序排列

```js
  1.条件渲染 (元素是否渲染/显示)
    v-if
    v-else-if
    v-else
    v-show
    v-cloak
  2.列表渲染相关
    v-for
    key
  3.唯一的 attribute 
    id
    ref
  4.class与style
  5.绑定渲染方式 (改变元素的渲染方式)
    v-pre
    v-once
  6.双向绑定 (把绑定和事件结合起来)
    v-model
  7.其它 attribute (所有普通的绑定或未绑定的 attribute)
  8.事件 (组件事件监听器)
    v-on
  9.内容 (覆写元素的内容)
    v-html
    v-text
```
#### 2.1.27 [规则]：多语言模板取代纯文本语言

> **[说明]：**组件中不能出现纯文本语言，要考虑到多语言的切换问题。

```js
  //good
  <template>
    <div
      v-if="error"
      key="search-status"
    >
      {{ this.$t('save')}}
    </div>
  </template>

  //bad
  <template>
    <div v-if="error">
      {{ '保存' }}
    </div>
  </template>
```
#### 2.1.28 [规则]：UI样式要兼容长文本词条

> **[说明]：**切换语言时，会出现长文本词条，导致文本溢出等情况，在编写样式时，需要兼容这些情况。

```js
  //good
  <template>
    <div
      v-if="error"
      key="search-status"
      class="base-ellipsis"
    >
      {{ this.$t('alertTips')}}
    </div>
  </template>
  <style lang="less" scoped>
  .base-layout-content {
    overflow: hidden;
    text-overflow: ellipsis;
    white-space: nowrap;
  }
  </style>

  //bad
  <template>
    <div v-if="error">
      {{ this.$t('alertTips')}}
    </div>
  </template>
```

#### 2.1.29 [规则]：组件编写样式时有严格的命名空间

> **[说明]：**开发的公共组件编写样式时要有严格的命名空间，要加上scope属性，避免全局样式污染。
```css
  //good
  <style lang="less" scoped>
  .base-layout-content {
    overflow: auto;
  }
  </style>

  //bad
  <style lang="less">
  .base-layout-content {
    overflow: auto;
  }
  </style>
```
#### 2.1.30 [建议]：使用组件名作为样式作用域空间

> **[说明]：**Vue.js 的组件是自定义元素，这非常适合用来作为样式的根作用域空间。可以将组件名作为 CSS 类的命名空间。
```css
  //good
  <style lang="less" scoped>
    .MyComponent { }
    .MyComponent li { }
    .MyComponent { }
  </style>

  //bad
  <style lang="less">
    .My-Component { } /* 没有用组件名或模块名限制作用域, 不符合 BEM 规范 */
  </style>

```

#### 2.1.31 [谨慎]：scoped 中的元素选择器谨慎使用

> **[说明]：**在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。

```css
  //good
  <template>
    <button class="btn btn-close">X</button>
  </template>

  <style scoped>
  .btn-close {
    background-color: red;
  }
  </style>

  //bad
  <template>
    <button>X</button>
  </template>

  <style scoped>
  button {
    background-color: red;
  }
  </style>
```
## 3.	更新说明
> **[说明]：**后续文档更新情况，将会通过邮件告知大家。